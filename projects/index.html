<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D City with Procedural Sky</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #111; color: #fff; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 8px;
            font-size: 14px;
            color: #eee;
            z-index: 100;
            max-width: 300px;
        }
        #instructions h2 { margin-top: 0; font-size: 16px; }
        #instructions p { margin-bottom: 5px; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 1px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* So it doesn't interfere with pointer lock */
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #messageBox {
            width: 300px;
            padding: 20px;
            background-color: #fff;
            color: #333;
            text-align: center;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
        }
        #messageBox button {
            padding: 10px 20px;
            margin-top: 15px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        #messageBox button:hover {
            background-color: #0056b3;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
    }
    </script>

</head>
<body>
    <div id="blocker">
        <div id="messageBox">
            <h2>Explore the City</h2>
            <p>Click to look around with the mouse.</p>
            <p>Use WASD keys to move.</p>
            <p>Press SPACE to Jump.</p>
            <button id="startButton">Start Exploring</button>
        </div>
    </div>

    <div id="instructions">
        <h2>Controls</h2>
        <p><strong>Mouse:</strong> Look around</p>
        <p><strong>W:</strong> Move Forward</p>
        <p><strong>A:</strong> Strafe Left</p>
        <p><strong>S:</strong> Move Backward</p>
        <p><strong>D:</strong> Strafe Right</p>
        <p><strong>Space:</strong> Jump</p>
        <p><strong>ESC:</strong> Release mouse control</p>
    </div>
    <div id="crosshair" style="display: none;"></div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { Sky } from 'three/addons/objects/Sky.js'; // Import Sky

        let scene, camera, renderer, controls, sky, sun;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = true;

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const clock = new THREE.Clock();

        // Player parameters
        const playerHeight = 10; 
        const gravity = 30.0;
        const jumpStrength = 150.0;
        const playerMoveSpeed = 200.0;
        const playerCollisionWidth = 1.5; 
        const playerCollisionDepth = 1.5;


        // City parameters
        const buildingColors = [0x888888, 0xaaaaaa, 0xcccccc, 0x777777, 0x999999];
        const shopColors = [0xff6666, 0x66ff66, 0x6666ff, 0xffff66, 0xff66ff];
        const roadColor = 0x333333;
        const groundColor = 0x55aa55; 
        const carColors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xff00ff, 0x00ffff];

        const roadWidth = 20;
        const buildingSpacing = 5; 
        const blockSize = 100; 
        const numBlocks = 5; 

        const actualCityRadius = numBlocks * (blockSize + roadWidth) + roadWidth / 2;
        const citySize = actualCityRadius * 2; 

        // Car parameters
        const cars = [];
        const numCars = 30; 
        const carSpeedMin = 30;
        const carSpeedMax = 70;

        // Building storage for collisions
        const buildings = [];

        // Materials for building features
        const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x5C3A21, roughness: 0.8, metalness: 0.1 }); 
        const windowMaterial = new THREE.MeshStandardMaterial({ color: 0x7CB9E8, roughness: 0.3, metalness: 0.2 }); 

        // Materials and Geometries for Scenery
        const treeTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 }); 
        const treeFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8 }); 
        const lampPostMaterial = new THREE.MeshStandardMaterial({ color: 0x606060, roughness: 0.6, metalness: 0.4 }); 
        const lampLightMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF99, emissive: 0xFFFF99, emissiveIntensity: 1 }); 
        const streetSignPoleMaterial = new THREE.MeshStandardMaterial({ color: 0x777777, roughness: 0.7 });
        const streetSignBoardMaterial = new THREE.MeshStandardMaterial({ color: 0x006400, roughness: 0.8 }); 
        let streetSignTextMaterial; 

        let sharedTreeTrunkGeometry, sharedTreeFoliageGeometry;
        let sharedLampPostGeometry, sharedLampLightGeometry;
        let streetNameFont;

        const ewStreetNames = ["Main St", "Oak Ave", "Elm Dr", "Cedar Ln", "Maple Rd", "Willow Way", "River Run", "Pine Pass", "Birch Blvd", "Aspen Cres", "Canyon Rd"];
        const nsStreetNames = ["Park Ave", "Highland Dr", "Valley Rd", "Sunset Blvd", "Sunrise Ave", "Central St", "First St", "Second St", "Third Ave", "Fourth Way", "Fifth Pl"];

        // Reusable Box3 for player collider
        let playerColliderBox = new THREE.Box3();

        init();
        animate();

        // Updates a THREE.Box3 to represent the player's collision volume.
        function updatePlayerColliderBox(centerPosition, outBox) {
            const halfWidth = playerCollisionWidth / 2;
            const halfDepth = playerCollisionDepth / 2;
            const feetY = centerPosition.y - playerHeight; 
            const headY = centerPosition.y; 

            outBox.min.set(centerPosition.x - halfWidth, feetY, centerPosition.z - halfDepth);
            outBox.max.set(centerPosition.x + halfWidth, headY, centerPosition.z + halfDepth);
            // No need to return, outBox is modified directly.
        }


        function init() {
            scene = new THREE.Scene();
            // scene.background is now handled by the Sky object itself
            
            // Initialize Sky
            sky = new Sky();
            sky.scale.setScalar(citySize * 2); // Make sky dome very large
            scene.add(sky);

            sun = new THREE.Vector3(); // Sun position vector for Sky shader

            // Sky shader parameters
            const effectController = {
                turbidity: 10,
                rayleigh: 2, // Lower for less blue, higher for more intense blue
                mieCoefficient: 0.005,
                mieDirectionalG: 0.8,
                elevation: 6, // Sun elevation in degrees (0 is horizon, 90 is directly overhead)
                azimuth: 180, // Sun azimuth in degrees (horizontal direction)
                // exposure: renderer.toneMappingExposure // This would be set if using tone mapping
            };

            const uniforms = sky.material.uniforms;
            uniforms['turbidity'].value = effectController.turbidity;
            uniforms['rayleigh'].value = effectController.rayleigh;
            uniforms['mieCoefficient'].value = effectController.mieCoefficient;
            uniforms['mieDirectionalG'].value = effectController.mieDirectionalG;

            const phi = THREE.MathUtils.degToRad(90 - effectController.elevation);
            const theta = THREE.MathUtils.degToRad(effectController.azimuth);
            sun.setFromSphericalCoords(1, phi, theta); // Distance 1, as it's a direction
            uniforms['sunPosition'].value.copy(sun);

            // Fog - Adjust color to blend with the sky
            // The fog color should ideally match the horizon color of the procedural sky.
            // This might require some trial and error or a more dynamic approach.
            // For now, a light blue that's less saturated than the previous one.
            scene.fog = new THREE.Fog(0xA0C0E0, 150, actualCityRadius * 1.4); 


            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, citySize * 2); // Increased far plane for sky

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            // renderer.toneMapping = THREE.ACESFilmicToneMapping; // Optional: for better color grading with Sky
            // renderer.toneMappingExposure = 0.5; // Adjust exposure if tone mapping is used
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Adjusted ambient light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Slightly adjusted intensity
            // Align directional light with the sun position from the sky shader for consistency
            directionalLight.position.set(sun.x, sun.y, sun.z).multiplyScalar(actualCityRadius * 0.5); // Scale sun direction to a position
            directionalLight.target.position.set(0,0,0); // Ensure light points towards origin
            scene.add(directionalLight.target);

            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = citySize * 1.5; // Adjusted shadow camera far plane
            directionalLight.shadow.camera.left = -actualCityRadius * 1.2; 
            directionalLight.shadow.camera.right = actualCityRadius* 1.2;
            directionalLight.shadow.camera.top = actualCityRadius * 1.2;
            directionalLight.shadow.camera.bottom = -actualCityRadius * 1.2;
            scene.add(directionalLight);

            const groundGeometry = new THREE.PlaneGeometry(citySize, citySize); 
            const groundMaterial = new THREE.MeshStandardMaterial({ color: groundColor, roughness: 0.8, metalness: 0.2 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            sharedTreeTrunkGeometry = new THREE.CylinderGeometry(1, 1.5, 12, 8); 
            sharedTreeFoliageGeometry = new THREE.SphereGeometry(6, 8, 6); 
            sharedLampPostGeometry = new THREE.CylinderGeometry(0.5, 0.75, 18, 8);
            sharedLampLightGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);

            const fontLoader = new FontLoader();
            fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.164.1/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                streetNameFont = font;
                streetSignTextMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 }); 
                createStreetSigns(); 
            });


            createRoads();
            createBuildings(); 
            createCars();
            createTrees();
            createLampPosts();

            controls = new PointerLockControls(camera, document.body);
            controls.getObject().position.y = playerHeight; 
            scene.add(controls.getObject());


            const blocker = document.getElementById('blocker');
            const startButton = document.getElementById('startButton');
            const crosshair = document.getElementById('crosshair');

            startButton.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => {
                blocker.style.display = 'none';
                crosshair.style.display = 'block';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex';
                crosshair.style.display = 'none';
            });

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize, false);
        }

        function createRoads() {
            const roadMaterial = new THREE.MeshStandardMaterial({ color: roadColor, roughness: 0.9 });
            const roadHeight = 0.2;
            for (let i = -numBlocks; i <= numBlocks; i++) {
                const roadLinePos = i * (blockSize + roadWidth) - roadWidth / 2;
                
                const roadZ = new THREE.Mesh(new THREE.BoxGeometry(roadWidth, roadHeight, citySize), roadMaterial);
                roadZ.position.set(roadLinePos, roadHeight / 2, 0);
                roadZ.castShadow = true; roadZ.receiveShadow = true;
                scene.add(roadZ);

                const roadX = new THREE.Mesh(new THREE.BoxGeometry(citySize, roadHeight, roadWidth), roadMaterial);
                roadX.position.set(0, roadHeight / 2, roadLinePos);
                roadX.castShadow = true; roadX.receiveShadow = true;
                scene.add(roadX);
            }
        }
        
        // Note: windowInstances, doorInstances, currentWindowInstanceIndex, currentDoorInstanceIndex, standardDoorGeometry, standardWindowGeometry, dummyFeature
        // are now defined at the start of createBuildings() and are accessible by this function.
        function addBuildingFeatures(building, buildingScaledWidth, buildingScaledHeight, buildingScaledDepth, isShop,
                                     windowInstances, doorInstances, currentWindowInstanceIndexRef, currentDoorInstanceIndexRef,
                                     standardWindowGeometry, standardDoorGeometry, dummyFeature) {
            const doorBoxThickness = 0.2; // Standard depth, matches geometry if not scaled in Z
            const windowBoxThickness = 0.1; // Standard depth
            const frontFaceZ = building.position.z + buildingScaledDepth / 2;

            // Door
            const actualDoorHeight = Math.min(buildingScaledHeight * 0.25, playerHeight * 1.3);
            const actualDoorWidth = buildingScaledWidth * 0.2;
            if (buildingScaledHeight > actualDoorHeight * 1.1 && currentDoorInstanceIndexRef.value < doorInstances.count) {
                dummyFeature.position.set(
                    building.position.x,
                    building.position.y - buildingScaledHeight / 2 + actualDoorHeight / 2,
                    frontFaceZ + doorBoxThickness / 2
                );
                dummyFeature.scale.set(
                    actualDoorWidth / standardDoorGeometry.parameters.width,
                    actualDoorHeight / standardDoorGeometry.parameters.height,
                    doorBoxThickness / standardDoorGeometry.parameters.depth // Assuming standard geometry depth is used
                );
                dummyFeature.updateMatrix();
                doorInstances.setMatrixAt(currentDoorInstanceIndexRef.value, dummyFeature.matrix);
                currentDoorInstanceIndexRef.value++;
            }

            // Windows on Z-face (front/back of building)
            const actualWindowSizeForZFace = Math.min(buildingScaledWidth * 0.12, buildingScaledHeight * 0.1);
            const windowSpacingZ = actualWindowSizeForZFace * 1.8;
            let startWindowY_ZFace = building.position.y - buildingScaledHeight / 2 + ( (buildingScaledHeight > actualDoorHeight * 1.1) ? actualDoorHeight : 0 ) + actualWindowSizeForZFace * 0.5;
            let shopSignBottomEdge = -Infinity, shopSignTopEdge = -Infinity;
            if (isShop) {
                const shopSignHeight = Math.max(5, buildingScaledHeight * 0.1);
                const shopSignCenterY = building.position.y - buildingScaledHeight / 2 + buildingScaledHeight * 0.7;
                shopSignBottomEdge = shopSignCenterY - shopSignHeight / 2;
                shopSignTopEdge = shopSignCenterY + shopSignHeight / 2;
            }

            for (let y = startWindowY_ZFace; y < building.position.y + buildingScaledHeight / 2 - actualWindowSizeForZFace; y += windowSpacingZ) {
                if (isShop && (Math.max(y, shopSignBottomEdge) < Math.min(y + actualWindowSizeForZFace, shopSignTopEdge))) continue;
                for (let x = building.position.x - buildingScaledWidth / 2 + actualWindowSizeForZFace * 0.5; x < building.position.x + buildingScaledWidth / 2 - actualWindowSizeForZFace * 0.25; x += windowSpacingZ) {
                    if (Math.random() > 0.15 && currentWindowInstanceIndexRef.value < windowInstances.count) {
                        dummyFeature.position.set(x, y, frontFaceZ + windowBoxThickness / 2);
                        dummyFeature.scale.set(
                            actualWindowSizeForZFace / standardWindowGeometry.parameters.width,
                            actualWindowSizeForZFace / standardWindowGeometry.parameters.height,
                            windowBoxThickness / standardWindowGeometry.parameters.depth
                        );
                        dummyFeature.updateMatrix();
                        windowInstances.setMatrixAt(currentWindowInstanceIndexRef.value, dummyFeature.matrix);
                        currentWindowInstanceIndexRef.value++;
                    }
                }
            }

            // Windows on X-face (sides of building)
            const sideFaceX = building.position.x + buildingScaledWidth / 2; // Assuming windows on +X side
            const actualWindowSizeForXFace = Math.min(buildingScaledDepth * 0.12, buildingScaledHeight * 0.1);
            const windowSpacingX = actualWindowSizeForXFace * 1.8;
            let startWindowY_XFace = building.position.y - buildingScaledHeight / 2 + actualWindowSizeForXFace * 0.5;

            for (let y = startWindowY_XFace; y < building.position.y + buildingScaledHeight / 2 - actualWindowSizeForXFace; y += windowSpacingX) {
                for (let z = building.position.z - buildingScaledDepth / 2 + actualWindowSizeForXFace * 0.5; z < building.position.z + buildingScaledDepth / 2 - actualWindowSizeForXFace * 0.25; z += windowSpacingX) {
                     if (Math.random() > 0.2 && currentWindowInstanceIndexRef.value < windowInstances.count) {
                        // For X-face windows, the geometry is rotated if width != height.
                        // Standard geometry is Box(width, height, depth). For side windows, width is along building depth, height is vertical.
                        // The windowBoxThickness here applies to the "depth" of the window inset into the wall.
                        dummyFeature.position.set(sideFaceX + windowBoxThickness / 2, y, z); // Depth of window inset for X-face
                        dummyFeature.scale.set(
                            windowBoxThickness / standardWindowGeometry.parameters.width, // This seems to map window depth to standard width
                            actualWindowSizeForXFace / standardWindowGeometry.parameters.height, // Maps actual height to standard height
                            actualWindowSizeForXFace / standardWindowGeometry.parameters.depth   // Maps actual width (along building Z) to standard depth
                        );
                        // If standardWindowGeometry is (std_w, std_h, std_d)
                        // We want the mesh to be (windowBoxThickness, actualWindowSizeForXFace, actualWindowSizeForXFace)
                        // So scale factors:
                        // scale.x = windowBoxThickness / std_w
                        // scale.y = actualWindowSizeForXFace / std_h
                        // scale.z = actualWindowSizeForXFace / std_d
                        // The previous xFaceWindowGeometry was new THREE.BoxGeometry(windowBoxThickness, windowSizeForXFace, windowSizeForXFace)
                        // So this scaling logic is correct.
                        dummyFeature.updateMatrix();
                        windowInstances.setMatrixAt(currentWindowInstanceIndexRef.value, dummyFeature.matrix);
                        currentWindowInstanceIndexRef.value++;
                    }
                }
            }
            // Could add windows for -X face and -Z face as well if desired, by creating another loop or adjusting positions.
            // For now, only +X and +Z faces get windows/doors.
        }

        function createBuildings() {
            const buildingBaseGeometry = new THREE.BoxGeometry(1, 1, 1);

            // Standard dimensions for instanced geometries
            const standardDoorWidth = 2;
            const standardDoorHeight = 4;
            const standardDoorDepth = 0.2;
            const standardWindowSize = 1.5; // Assuming square for simplicity, depth is windowBoxThickness
            const standardWindowDepth = 0.1;

            const standardDoorGeometry = new THREE.BoxGeometry(standardDoorWidth, standardDoorHeight, standardDoorDepth);
            const standardWindowGeometry = new THREE.BoxGeometry(standardWindowSize, standardWindowSize, standardWindowDepth);

            const buildingsPerBlockMax = 2; // From existing logic
            const windowsPerBuildingMax = 100; // Generous estimate
            const doorsPerBuildingMax = 1;   // Typically one door

            const maxWindows = numBlocks * numBlocks * buildingsPerBlockMax * windowsPerBuildingMax;
            const maxDoors = numBlocks * numBlocks * buildingsPerBlockMax * doorsPerBuildingMax;

            const windowInstances = new THREE.InstancedMesh(standardWindowGeometry, windowMaterial, maxWindows);
            windowInstances.castShadow = false;
            windowInstances.receiveShadow = false;
            scene.add(windowInstances);

            const doorInstances = new THREE.InstancedMesh(standardDoorGeometry, doorMaterial, maxDoors);
            doorInstances.castShadow = false;
            doorInstances.receiveShadow = false;
            scene.add(doorInstances);

            let currentWindowInstanceIndexRef = { value: 0 }; // Using object wrapper for pass-by-reference behavior
            let currentDoorInstanceIndexRef = { value: 0 };
            const dummyFeature = new THREE.Object3D();

            for (let i = -numBlocks; i < numBlocks; i++) { 
                for (let j = -numBlocks; j < numBlocks; j++) { 
                    const blockCenterX = i * (blockSize + roadWidth) + blockSize / 2;
                    const blockCenterZ = j * (blockSize + roadWidth) + blockSize / 2;
                    
                    const buildingsPerBlock = Math.floor(Math.random() * 2) + 1; 
                    for (let k_building = 0; k_building < buildingsPerBlock; k_building++) { // Renamed k to k_building for clarity
                        const isShop = Math.random() < 0.2;
                        const currentBuildingWidth = Math.random() * (blockSize / 2.5) + (blockSize / 5); 
                        const currentBuildingDepth = Math.random() * (blockSize / 2.5) + (blockSize / 5);
                        const currentBuildingHeight = isShop ? (Math.random() * 25 + 12) : (Math.random() * 80 + 30); 
                        
                        const buildingMaterial = new THREE.MeshStandardMaterial({
                            color: isShop ? shopColors[Math.floor(Math.random() * shopColors.length)] : buildingColors[Math.floor(Math.random() * buildingColors.length)],
                            roughness: 0.7, metalness: 0.1
                        });
                        const building = new THREE.Mesh(buildingBaseGeometry, buildingMaterial);
                        building.scale.set(currentBuildingWidth, currentBuildingHeight, currentBuildingDepth);
                        
                        const offsetX = (Math.random() - 0.5) * (blockSize - currentBuildingWidth - buildingSpacing);
                        const offsetZ = (Math.random() - 0.5) * (blockSize - currentBuildingDepth - buildingSpacing);
                        building.position.set(blockCenterX + offsetX, currentBuildingHeight / 2, blockCenterZ + offsetZ);
                        building.castShadow = true; 
                        building.receiveShadow = true; 
                        scene.add(building);

                        building.updateMatrixWorld(); 
                        const buildingBox = new THREE.Box3().setFromObject(building);
                        buildings.push({ mesh: building, boundingBox: buildingBox });

                        addBuildingFeatures(
                            building, currentBuildingWidth, currentBuildingHeight, currentBuildingDepth, isShop,
                            windowInstances, doorInstances, currentWindowInstanceIndexRef, currentDoorInstanceIndexRef,
                            standardWindowGeometry, standardDoorGeometry, dummyFeature
                        );

                        if (isShop) {
                            const signVisualHeight = Math.max(5, currentBuildingHeight * 0.1); 
                            const signVisualDepth = 2; 
                            const signVisualWidth = currentBuildingWidth * 0.8;
                            const signGeometry = new THREE.BoxGeometry(signVisualWidth, signVisualHeight, signVisualDepth);
                            const signMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
                            const sign = new THREE.Mesh(signGeometry, signMaterial);
                            sign.position.set(building.position.x, building.position.y - currentBuildingHeight / 2 + currentBuildingHeight * 0.7, building.position.z + currentBuildingDepth / 2 + signVisualDepth / 2 );
                            sign.castShadow = true; 
                            scene.add(sign);
                        }
                    }
                }
            }
            windowInstances.count = currentWindowInstanceIndexRef.value;
            doorInstances.count = currentDoorInstanceIndexRef.value;
            windowInstances.instanceMatrix.needsUpdate = true;
            doorInstances.instanceMatrix.needsUpdate = true;
        }

        function createCars() {
            const carGeometry = new THREE.BoxGeometry(8, 4, 15); 
            for (let i = 0; i < numCars; i++) {
                const carMaterial = new THREE.MeshStandardMaterial({ color: carColors[Math.floor(Math.random() * carColors.length)], roughness: 0.4, metalness: 0.2 });
                const carMesh = new THREE.Mesh(carGeometry, carMaterial); 
                carMesh.castShadow = true; 
                carMesh.receiveShadow = true;
                const car = { mesh: carMesh, speed: Math.random() * (carSpeedMax - carSpeedMin) + carSpeedMin, axis: Math.random() > 0.5 ? 'x' : 'z', direction: Math.random() > 0.5 ? 1 : -1, };
                const randomRoadIndex = Math.floor(Math.random() * (2 * numBlocks + 1)) - numBlocks;
                const roadLinePos = randomRoadIndex * (blockSize + roadWidth) - roadWidth / 2;
                const carYPosition = 0.2 / 2 + 4 / 2; 
                if (car.axis === 'x') { 
                    car.mesh.position.set((Math.random() - 0.5) * citySize, carYPosition, roadLinePos + (Math.random() > 0.5 ? roadWidth / 4 : -roadWidth / 4));
                    if (carGeometry.parameters.depth > carGeometry.parameters.width) car.mesh.rotation.y = Math.PI / 2;
                } else { 
                    car.mesh.position.set(roadLinePos + (Math.random() > 0.5 ? roadWidth / 4 : -roadWidth / 4), carYPosition, (Math.random() - 0.5) * citySize);
                }
                cars.push(car); scene.add(car.mesh);
            }
        }

        function createTrees() {
            const treesPerBlockLength = 2;
            const treeOffsetFromRoadCenter = roadWidth / 2 + 10;
            const numRoads = 2 * numBlocks + 1;
            const blocksPerRoad = 2 * numBlocks; // Trees are placed along 'numBlocks' on each side of a road, but the loop goes from -numBlocks to < numBlocks

            // Calculate max instances:
            // Each road (numRoads) has 'blocksPerRoad' segments where trees can be placed.
            // Each segment has 'treesPerBlockLength' trees.
            // Each placement results in 2 trees (one on each side of the road).
            // This logic is applied for both X-axis roads and Z-axis roads.
            const maxTreesPerOrientation = numRoads * blocksPerRoad * treesPerBlockLength * 2;
            const totalMaxTrees = maxTreesPerOrientation; // This seems to double count, let's verify the loop logic
                                                           // The loops iterate over (2*numBlocks+1) roads.
                                                           // For each road, they iterate '2*numBlocks' block segments.
                                                           // In each segment, 'treesPerBlockLength' positions are chosen.
                                                           // At each position, 2 trees are placed (offset + and offset -).
                                                           // So for one orientation (e.g. roads along Z): (2*numBlocks+1) * (2*numBlocks) * treesPerBlockLength * 2
                                                           // Total trees = 2 * ( (2*numBlocks+1) * (2*numBlocks) * treesPerBlockLength * 2 ) - but this is too high.

            // Let's recalculate based on the loops:
            // First loop (roads along Z, trees placed parallel to X):
            // (2 * numBlocks + 1) iterations for road_idx
            // (2 * numBlocks) iterations for block_col_idx
            // treesPerBlockLength iterations for k
            // 2 calls to placeTree per k
            let count = 0;
            for (let road_idx = -numBlocks; road_idx <= numBlocks; road_idx++) {
                for (let block_col_idx = -numBlocks; block_col_idx < numBlocks; block_col_idx++) {
                    const blockXStart = block_col_idx * (blockSize + roadWidth) - roadWidth/2;
                    const treeSpacing = blockSize / (treesPerBlockLength + 1);
                    for (let k = 1; k <= treesPerBlockLength; k++) {
                        const xPos = blockXStart + k * treeSpacing;
                        if (xPos >= -actualCityRadius && xPos <= actualCityRadius) {
                             count += 2; // placeTree(xPos, roadZCenter + treeOffsetFromRoadCenter); placeTree(xPos, roadZCenter - treeOffsetFromRoadCenter);
                        }
                    }
                }
            }
            // Second loop (roads along X, trees placed parallel to Z):
            for (let road_idx = -numBlocks; road_idx <= numBlocks; road_idx++) {
                for (let block_row_idx = -numBlocks; block_row_idx < numBlocks; block_row_idx++) {
                    const blockZStart = block_row_idx * (blockSize + roadWidth) - roadWidth/2;
                    const treeSpacing = blockSize / (treesPerBlockLength + 1);
                    for (let k = 1; k <= treesPerBlockLength; k++) {
                        const zPos = blockZStart + k * treeSpacing;
                        if (zPos >= -actualCityRadius && zPos <= actualCityRadius) {
                            count += 2; // placeTree(roadXCenter + treeOffsetFromRoadCenter, zPos); placeTree(roadXCenter - treeOffsetFromRoadCenter, zPos);
                        }
                    }
                }
            }
            const maxTrunks = count;
            const maxFoliage = count;

            const trunkInstanceGeometry = sharedTreeTrunkGeometry.clone();
            const trunkInstances = new THREE.InstancedMesh(trunkInstanceGeometry, treeTrunkMaterial, maxTrunks);
            trunkInstances.castShadow = true;
            trunkInstances.receiveShadow = true;
            scene.add(trunkInstances);

            const foliageInstanceGeometry = sharedTreeFoliageGeometry.clone();
            const foliageInstances = new THREE.InstancedMesh(foliageInstanceGeometry, treeFoliageMaterial, maxFoliage);
            foliageInstances.castShadow = true;
            foliageInstances.receiveShadow = true;
            scene.add(foliageInstances);

            const dummy = new THREE.Object3D();
            let trunkInstanceIndex = 0;
            let foliageInstanceIndex = 0;

            // Helper function to set matrix for an instance
            function setInstanceMatrix(instances, index, x, y, z) {
                dummy.position.set(x, y, z);
                dummy.updateMatrix();
                instances.setMatrixAt(index, dummy.matrix);
            }

            for (let road_idx = -numBlocks; road_idx <= numBlocks; road_idx++) {
                const roadZCenter = road_idx * (blockSize + roadWidth) - roadWidth / 2;
                for (let block_col_idx = -numBlocks; block_col_idx < numBlocks; block_col_idx++) {
                    const blockXStart = block_col_idx * (blockSize + roadWidth) - roadWidth/2;
                    const treeSpacing = blockSize / (treesPerBlockLength + 1);
                    for (let k = 1; k <= treesPerBlockLength; k++) {
                        const xPos = blockXStart + k * treeSpacing;
                        if (xPos >= -actualCityRadius && xPos <= actualCityRadius) {
                            // Tree 1
                            setInstanceMatrix(trunkInstances, trunkInstanceIndex++, xPos, 6, roadZCenter + treeOffsetFromRoadCenter);
                            setInstanceMatrix(foliageInstances, foliageInstanceIndex++, xPos, 12 + 5, roadZCenter + treeOffsetFromRoadCenter);
                            // Tree 2
                            setInstanceMatrix(trunkInstances, trunkInstanceIndex++, xPos, 6, roadZCenter - treeOffsetFromRoadCenter);
                            setInstanceMatrix(foliageInstances, foliageInstanceIndex++, xPos, 12 + 5, roadZCenter - treeOffsetFromRoadCenter);
                        }
                    }
                }
            }

            for (let road_idx = -numBlocks; road_idx <= numBlocks; road_idx++) {
                const roadXCenter = road_idx * (blockSize + roadWidth) - roadWidth / 2;
                for (let block_row_idx = -numBlocks; block_row_idx < numBlocks; block_row_idx++) {
                    const blockZStart = block_row_idx * (blockSize + roadWidth) - roadWidth/2;
                    const treeSpacing = blockSize / (treesPerBlockLength + 1);
                    for (let k = 1; k <= treesPerBlockLength; k++) {
                        const zPos = blockZStart + k * treeSpacing;
                        if (zPos >= -actualCityRadius && zPos <= actualCityRadius) {
                            // Tree 3
                            setInstanceMatrix(trunkInstances, trunkInstanceIndex++, roadXCenter + treeOffsetFromRoadCenter, 6, zPos);
                            setInstanceMatrix(foliageInstances, foliageInstanceIndex++, roadXCenter + treeOffsetFromRoadCenter, 12 + 5, zPos);
                            // Tree 4
                            setInstanceMatrix(trunkInstances, trunkInstanceIndex++, roadXCenter - treeOffsetFromRoadCenter, 6, zPos);
                            setInstanceMatrix(foliageInstances, foliageInstanceIndex++, roadXCenter - treeOffsetFromRoadCenter, 12 + 5, zPos);
                        }
                    }
                }
            }
            // Ensure instance counts are updated
            trunkInstances.instanceMatrix.needsUpdate = true;
            foliageInstances.instanceMatrix.needsUpdate = true;
        }

        // Removed placeLampPost function as it's replaced by instancing logic below

        function createLampPosts() {
            const lampsPerBlockLength = 1;
            const lampOffsetFromRoadCenter = roadWidth / 2 + 4;

            let lampCount = 0;
            // Calculate max instances for lamp posts and lights
            for (let road_idx = -numBlocks; road_idx <= numBlocks; road_idx++) {
                for (let block_col_idx = -numBlocks; block_col_idx < numBlocks; block_col_idx++) {
                    const blockXStart = block_col_idx * (blockSize + roadWidth) - roadWidth/2;
                    const lampSpacing = blockSize / (lampsPerBlockLength + 1);
                    for (let k = 1; k <= lampsPerBlockLength; k++) {
                        const xPos = blockXStart + k * lampSpacing;
                        if (xPos >= -actualCityRadius && xPos <= actualCityRadius) {
                            lampCount += 2; // Two lamps per position
                        }
                    }
                }
            }
            for (let road_idx = -numBlocks; road_idx <= numBlocks; road_idx++) {
                for (let block_row_idx = -numBlocks; block_row_idx < numBlocks; block_row_idx++) {
                    const blockZStart = block_row_idx * (blockSize + roadWidth) - roadWidth/2;
                    const lampSpacing = blockSize / (lampsPerBlockLength + 1);
                    for (let k = 1; k <= lampsPerBlockLength; k++) {
                        const zPos = blockZStart + k * lampSpacing;
                        if (zPos >= -actualCityRadius && zPos <= actualCityRadius) {
                            lampCount += 2; // Two lamps per position
                        }
                    }
                }
            }
            const maxPosts = lampCount;
            const maxLights = lampCount;

            const postInstanceGeometry = sharedLampPostGeometry.clone();
            const postInstances = new THREE.InstancedMesh(postInstanceGeometry, lampPostMaterial, maxPosts);
            postInstances.castShadow = true;
            postInstances.receiveShadow = true;
            scene.add(postInstances);

            const lightInstanceGeometry = sharedLampLightGeometry.clone();
            const lightInstances = new THREE.InstancedMesh(lightInstanceGeometry, lampLightMaterial, maxLights);
            lightInstances.castShadow = false; // Lights themselves don't cast shadows
            lightInstances.receiveShadow = false;
            scene.add(lightInstances);

            const dummyLamp = new THREE.Object3D(); // Dummy object for lamps
            let postInstanceIndex = 0;
            let lightInstanceIndex = 0;

            // Helper function to set matrix for lamp instances
            function setLampInstanceMatrix(instances, index, x, y, z) {
                dummyLamp.position.set(x, y, z);
                dummyLamp.updateMatrix();
                instances.setMatrixAt(index, dummyLamp.matrix);
            }

            for (let road_idx = -numBlocks; road_idx <= numBlocks; road_idx++) {
                const roadZCenter = road_idx * (blockSize + roadWidth) - roadWidth / 2;
                for (let block_col_idx = -numBlocks; block_col_idx < numBlocks; block_col_idx++) {
                    const blockXStart = block_col_idx * (blockSize + roadWidth) - roadWidth/2;
                    const lampSpacing = blockSize / (lampsPerBlockLength + 1);
                    for (let k = 1; k <= lampsPerBlockLength; k++) {
                        const xPos = blockXStart + k * lampSpacing;
                        if (xPos >= -actualCityRadius && xPos <= actualCityRadius) {
                            // Lamp Post 1
                            setLampInstanceMatrix(postInstances, postInstanceIndex++, xPos, 9, roadZCenter + lampOffsetFromRoadCenter);
                            setLampInstanceMatrix(lightInstances, lightInstanceIndex++, xPos, 18 + 0.75, roadZCenter + lampOffsetFromRoadCenter);
                            // Lamp Post 2
                            setLampInstanceMatrix(postInstances, postInstanceIndex++, xPos, 9, roadZCenter - lampOffsetFromRoadCenter);
                            setLampInstanceMatrix(lightInstances, lightInstanceIndex++, xPos, 18 + 0.75, roadZCenter - lampOffsetFromRoadCenter);
                        }
                    }
                }
            }

            for (let road_idx = -numBlocks; road_idx <= numBlocks; road_idx++) {
                const roadXCenter = road_idx * (blockSize + roadWidth) - roadWidth / 2;
                for (let block_row_idx = -numBlocks; block_row_idx < numBlocks; block_row_idx++) {
                    const blockZStart = block_row_idx * (blockSize + roadWidth) - roadWidth/2;
                    const lampSpacing = blockSize / (lampsPerBlockLength + 1);
                    for (let k = 1; k <= lampsPerBlockLength; k++) {
                        const zPos = blockZStart + k * lampSpacing;
                        if (zPos >= -actualCityRadius && zPos <= actualCityRadius) {
                            // Lamp Post 3
                            setLampInstanceMatrix(postInstances, postInstanceIndex++, roadXCenter + lampOffsetFromRoadCenter, 9, zPos);
                            setLampInstanceMatrix(lightInstances, lightInstanceIndex++, roadXCenter + lampOffsetFromRoadCenter, 18 + 0.75, zPos);
                            // Lamp Post 4
                            setLampInstanceMatrix(postInstances, postInstanceIndex++, roadXCenter - lampOffsetFromRoadCenter, 9, zPos);
                            setLampInstanceMatrix(lightInstances, lightInstanceIndex++, roadXCenter - lampOffsetFromRoadCenter, 18 + 0.75, zPos);
                        }
                    }
                }
            }
            postInstances.instanceMatrix.needsUpdate = true;
            lightInstances.instanceMatrix.needsUpdate = true;
        }

        function createStreetSigns() {
            if (!streetNameFont || !streetSignTextMaterial) {
                console.warn("Street sign font or material not loaded yet.");
                return;
            }

            const signPostHeight = playerHeight + 5; 
            const signBoardHeight = 3;
            const signBoardWidth = 20;
            const signBoardDepth = 0.3;
            const textDepth = 0.1;
            const textSize = 1.2;
            const signPostRadius = 0.25;
            const signOffsetFromIntersectionCorner = roadWidth / 2 + 3; 

            const signPostGeometry = new THREE.CylinderGeometry(signPostRadius, signPostRadius, signPostHeight, 8);
            const signBoardGeometry = new THREE.BoxGeometry(signBoardWidth, signBoardHeight, signBoardDepth);

            for (let i = -numBlocks; i <= numBlocks; i++) { 
                const roadZ = i * (blockSize + roadWidth) - roadWidth / 2; 
                const ewStreetName = ewStreetNames[(i + numBlocks) % ewStreetNames.length];

                for (let j = -numBlocks; j <= numBlocks; j++) { 
                    const roadX = j * (blockSize + roadWidth) - roadWidth / 2; 
                    const nsStreetName = nsStreetNames[(j + numBlocks) % nsStreetNames.length];

                    const ewTextGeom = new TextGeometry(ewStreetName, { font: streetNameFont, size: textSize, height: textDepth, curveSegments: 2 });
                    ewTextGeom.computeBoundingBox();
                    const ewTextWidth = ewTextGeom.boundingBox.max.x - ewTextGeom.boundingBox.min.x;

                    const ewSignGroup = new THREE.Group();
                    const ewPost = new THREE.Mesh(signPostGeometry.clone(), streetSignPoleMaterial);
                    ewPost.castShadow = true;
                    ewPost.position.y = signPostHeight / 2;
                    const ewBoard = new THREE.Mesh(signBoardGeometry.clone(), streetSignBoardMaterial);
                    ewBoard.castShadow = true;
                    ewBoard.position.y = signPostHeight - signBoardHeight / 2 - 0.5; 
                    const ewTextMesh = new THREE.Mesh(ewTextGeom, streetSignTextMaterial); 
                    ewTextMesh.castShadow = false;
                    ewTextMesh.position.set(-ewTextWidth / 2, ewBoard.position.y - textSize * 0.4, signBoardDepth / 2 + textDepth * 0.1);
                    
                    ewSignGroup.add(ewPost, ewBoard, ewTextMesh);
                    ewSignGroup.position.set(roadX + signOffsetFromIntersectionCorner, 0, roadZ - signOffsetFromIntersectionCorner);
                    ewSignGroup.rotation.y = Math.PI / 2; 
                    scene.add(ewSignGroup);


                    const nsTextGeom = new TextGeometry(nsStreetName, { font: streetNameFont, size: textSize, height: textDepth, curveSegments: 2 });
                    nsTextGeom.computeBoundingBox();
                    const nsTextWidth = nsTextGeom.boundingBox.max.x - nsTextGeom.boundingBox.min.x;

                    const nsSignGroup = new THREE.Group();
                    const nsPost = new THREE.Mesh(signPostGeometry.clone(), streetSignPoleMaterial);
                    nsPost.castShadow = true;
                    nsPost.position.y = signPostHeight / 2;
                    const nsBoard = new THREE.Mesh(signBoardGeometry.clone(), streetSignBoardMaterial);
                    nsBoard.castShadow = true;
                    nsBoard.position.y = signPostHeight - signBoardHeight / 2 - 0.5;
                    const nsTextMesh = new THREE.Mesh(nsTextGeom, streetSignTextMaterial);
                    nsTextMesh.castShadow = false;
                    nsTextMesh.position.set(-nsTextWidth / 2, nsBoard.position.y - textSize * 0.4, signBoardDepth / 2 + textDepth * 0.1);

                    nsSignGroup.add(nsPost, nsBoard, nsTextMesh);
                    nsSignGroup.position.set(roadX - signOffsetFromIntersectionCorner, 0, roadZ + signOffsetFromIntersectionCorner);
                    scene.add(nsSignGroup);
                }
            }
        }


        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) velocity.y += jumpStrength; canJump = false; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const playerObject = controls.getObject();
            const prevPosition = playerObject.position.clone();

            // Update the global player collider box for this frame
            updatePlayerColliderBox(playerObject.position, playerColliderBox);


            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= gravity * 5.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward); 
                direction.x = Number(moveRight) - Number(moveLeft);     
                direction.normalize(); 

                const intendedDisplacementX = direction.x * playerMoveSpeed * delta;
                const intendedDisplacementZ = direction.z * playerMoveSpeed * delta;

                if (moveLeft || moveRight) controls.moveRight(intendedDisplacementX);
                if (moveForward || moveBackward) controls.moveForward(intendedDisplacementZ);

                playerObject.position.y += velocity.y * delta;

                let onSolidSurface = false; 
                let yCollisionResolvedThisLoop = false; 

                for (const building of buildings) {
                    const buildingBox = building.boundingBox;
                    // Use the pre-updated playerColliderBox for intersection checks
                    if (playerColliderBox.intersectsBox(buildingBox)) {
                        yCollisionResolvedThisLoop = false;
                        const prevFeetY = prevPosition.y - playerHeight;
                        const currentFeetY = playerObject.position.y - playerHeight; 

                        const landedOnThisBuilding = velocity.y <= 0 && prevFeetY >= buildingBox.max.y - 0.25 && currentFeetY <= buildingBox.max.y + 0.25;
                        const hitHeadOnThisBuilding = velocity.y > 0 && prevPosition.y <= buildingBox.min.y + 0.25 && playerObject.position.y >= buildingBox.min.y - 0.25;

                        if (landedOnThisBuilding) {
                            playerObject.position.y = buildingBox.max.y + playerHeight;
                            velocity.y = 0;
                            canJump = true;
                            onSolidSurface = true;
                            yCollisionResolvedThisLoop = true;
                        } else if (hitHeadOnThisBuilding) {
                            playerObject.position.y = buildingBox.min.y; 
                            velocity.y = 0;
                            yCollisionResolvedThisLoop = true;
                        }
                        
                        // Update playerColliderBox again if player position was adjusted due to Y collision
                        if(yCollisionResolvedThisLoop) {
                            updatePlayerColliderBox(playerObject.position, playerColliderBox);
                        }

                        if (yCollisionResolvedThisLoop && !playerColliderBox.intersectsBox(buildingBox)) {
                             if(onSolidSurface) break; 
                             continue; 
                        }
                        
                        if (playerColliderBox.intersectsBox(buildingBox) && !yCollisionResolvedThisLoop) {
                            playerObject.position.x = prevPosition.x;
                            playerObject.position.z = prevPosition.z;
                            velocity.x = 0; 
                            velocity.z = 0; 

                            // After XZ revert, update collider again before the final check
                            updatePlayerColliderBox(playerObject.position, playerColliderBox);

                            if (playerColliderBox.intersectsBox(buildingBox)) {
                                const feetAtRevertedXZ = playerObject.position.y - playerHeight;
                                if (velocity.y <= 0 && feetAtRevertedXZ <= buildingBox.max.y + 0.25 && feetAtRevertedXZ >= buildingBox.max.y - playerHeight * 0.5) {
                                    playerObject.position.y = buildingBox.max.y + playerHeight;
                                    velocity.y = 0;
                                    canJump = true;
                                    onSolidSurface = true;
                                } else if (!landedOnThisBuilding && !hitHeadOnThisBuilding) {
                                    playerObject.position.y = prevPosition.y;
                                    velocity.y = 0; 
                                }
                            }
                        }
                        if (onSolidSurface) break; 
                    }
                }

                if (!onSolidSurface && playerObject.position.y < playerHeight) {
                    playerObject.position.y = playerHeight;
                    velocity.y = 0;
                    canJump = true;
                }
            } 

            cars.forEach(car => {
                if (car.axis === 'x') {
                    car.mesh.position.x += car.speed * car.direction * delta;
                    if (car.mesh.position.x > actualCityRadius + 50) car.mesh.position.x = -actualCityRadius - 50;
                    if (car.mesh.position.x < -actualCityRadius - 50) car.mesh.position.x = actualCityRadius + 50;
                } else {
                    car.mesh.position.z += car.speed * car.direction * delta;
                    if (car.mesh.position.z > actualCityRadius + 50) car.mesh.position.z = -actualCityRadius - 50;
                    if (car.mesh.position.z < -actualCityRadius - 50) car.mesh.position.z = actualCityRadius + 50;
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
