{"version":3,"sources":["logo.svg","Particles.js","App.js","reportWebVitals.js","index.js"],"names":["Particles","count","mouse","mesh","useRef","light","useThree","size","viewport","aspect","width","dummy","useMemo","THREE","particles","temp","i","t","Math","random","factor","speed","xFactor","yFactor","zFactor","push","mx","my","useFrame","state","current","position","set","forEach","particle","a","cos","sin","b","s","scale","rotation","updateMatrix","setMatrixAt","matrix","instanceMatrix","needsUpdate","ref","distance","intensity","color","args","softShadows","App","className","style","flex","colorManagement","shadowMap","camera","fov","fallback","castShadow","PI","receiveShadow","attach","opacity","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.040bc905.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import * as THREE from 'three'\nimport React, { useRef, useMemo } from 'react'\nimport { useFrame, useThree } from '@react-three/fiber'\n// import './styles.css'\n\nexport default function Particles({ count, mouse }) {\n  const mesh = useRef()\n  const light = useRef()\n  const { size, viewport } = useThree()\n  const aspect = size.width / viewport.width\n\n  const dummy = useMemo(() => new THREE.Object3D(), [])\n  // Generate some random positions, speed factors and timings\n  const particles = useMemo(() => {\n    const temp = []\n    for (let i = 0; i < count; i++) {\n      const t = Math.random() * 100\n      const factor = 20 + Math.random() * 100\n      const speed = 0.01 + Math.random() / 200\n      const xFactor = -50 + Math.random() * 100\n      const yFactor = -50 + Math.random() * 100\n      const zFactor = -50 + Math.random() * 100\n      temp.push({ t, factor, speed, xFactor, yFactor, zFactor, mx: 0, my: 0 })\n    }\n    return temp\n  }, [count])\n  // The innards of this hook will run every frame\n  useFrame((state) => {\n    // Makes the light follow the mouse\n    light.current.position.set(mouse.current[0] / aspect, -mouse.current[1] / aspect, 0)\n    // Run through the randomized data to calculate some movement\n    particles.forEach((particle, i) => {\n      let { t, factor, speed, xFactor, yFactor, zFactor } = particle\n      // There is no sense or reason to any of this, just messing around with trigonometric functions\n      t = particle.t += speed / 2\n      const a = Math.cos(t) + Math.sin(t * 1) / 10\n      const b = Math.sin(t) + Math.cos(t * 2) / 10\n      const s = Math.cos(t)\n      particle.mx += (mouse.current[0] - particle.mx) * 0.01\n      particle.my += (mouse.current[1] * -1 - particle.my) * 0.01\n      // Update the dummy object\n      dummy.position.set(\n        (particle.mx / 10) * a + xFactor + Math.cos((t / 10) * factor) + (Math.sin(t * 1) * factor) / 10,\n        (particle.my / 10) * b + yFactor + Math.sin((t / 10) * factor) + (Math.cos(t * 2) * factor) / 10,\n        (particle.my / 10) * b + zFactor + Math.cos((t / 10) * factor) + (Math.sin(t * 3) * factor) / 10\n      )\n      dummy.scale.set(s, s, s)\n      dummy.rotation.set(s * 5, s * 5, s * 5)\n      dummy.updateMatrix()\n      // And apply the matrix to the instanced item\n      mesh.current.setMatrixAt(i, dummy.matrix)\n    })\n    mesh.current.instanceMatrix.needsUpdate = true\n  })\n  return (\n    <>\n      <pointLight ref={light} distance={40} intensity={8} color=\"lightblue\" />\n      <instancedMesh ref={mesh} args={[null, null, count]}>\n        <dodecahedronGeometry args={[0.2, 0]} />\n        <meshPhongMaterial color='red' />\n      </instancedMesh>\n    </>\n  )\n}\n","import logo from './logo.svg';\nimport './App.css';\nimport * as THREE from 'three'\n\nimport React, { useRef, useState, Suspense } from \"react\";\n//R3F\nimport { Canvas, useFrame, useLoader } from \"@react-three/fiber\";\n// Deai - R3F\nimport { softShadows, MeshWobbleMaterial, OrbitControls } from '@react-three/drei';\n\n// React Spring\nimport { useSpring, a } from \"@react-spring/three\";\n\nimport img from './logo.png'\n\nimport Particles from './Particles'\n\n// soft Shadows\nsoftShadows();\n\nfunction Box(props) {\n  // This reference will give us direct access to the THREE.Mesh object\n  const ref = useRef()\n  // Set up state for the hovered and active state\n  const [hovered, setHover] = useState(false)\n  const [active, setActive] = useState(false)\n  // Subscribe this component to the render-loop, rotate the mesh every frame\n  useFrame((state, delta) => (ref.current.rotation.x += 0.01))\n  // Return the view, these are regular Threejs elements expressed in JSX\n\n  const texture = useLoader(THREE.TextureLoader, img)\n\n  return (\n    <mesh\n      {...props}\n      ref={ref}\n      scale={active ? 1.5 : 1}\n      onClick={(event) => setActive(!active)}\n      onPointerOver={(event) => setHover(true)}\n      onPointerOut={(event) => setHover(false)}>\n      <boxBufferGeometry attach=\"geometry\" />\n      <meshBasicMaterial attach=\"material\" map={texture} />\n      <meshBasicMaterial attach=\"material\" map={texture} />\n      <meshBasicMaterial attach=\"material\" map={texture} />\n      <meshBasicMaterial attach=\"material\" map={texture} />\n      <meshBasicMaterial attach=\"material\" map={texture} />\n      {/* <boxGeometry args={[1, 1, 1]} />\n      <meshStandardMaterial color={hovered ? 'hotpink' : 'orange'} /> */}\n    </mesh>\n  )\n}\n\nfunction Text(props) {\n  // This reference will give us direct access to the THREE.Mesh object\n  const ref = useRef()\n  // Set up state for the hovered and active state\n  const [hovered, setHover] = useState(false)\n  const [active, setActive] = useState(false)\n  // Subscribe this component to the render-loop, rotate the mesh every frame\n  useFrame((state, delta) => (ref.current.rotation.x += 0.01))\n  // Return the view, these are regular Threejs elements expressed in JSX\n\n  // // parse JSON file with Three\n  // const font = new THREE.FontLoader().parse(Roboto);\n\n  // // configure font geometry\n  // const textOptions = {\n  //   font,\n  //   size: 5,\n  //   height: 1\n  // };\n\n  return (\n    <mesh\n      {...props}\n      ref={ref}\n      scale={active ? 1.5 : 1}\n      onClick={(event) => setActive(!active)}\n      onPointerOver={(event) => setHover(true)}\n      onPointerOut={(event) => setHover(false)}>\n      <textGeometry attach='geometry' args={['three.js']} />\n      <meshStandardMaterial attach='material' />\n      {/* <boxGeometry args={[1, 1, 1]} />\n      <meshStandardMaterial color={hovered ? 'hotpink' : 'orange'} /> */}\n    </mesh>\n  )\n}\n\n\n\nconst SpinningMesh = ({ position, color, speed, args, rotate = true }) => {\n  //ref to target the mesh\n  const boxMesh = useRef();\n\n  //useFrame allows us to re-render/update rotation on each frame\n  // useFrame(() => (boxMesh.current.rotation.x = boxMesh.current.rotation.y));\n  useFrame(() => (boxMesh.current.rotation.x = boxMesh.current.rotation.y += (rotate ? 0.01 : 0)));\n\n  //Basic expand state\n  const [expand, setExpand] = useState(false);\n  // React spring expand animation\n  const props = useSpring({\n    scale: expand ? [1.4, 1.4, 1.4] : [1, 1, 1],\n  });\n  return (\n    <a.mesh\n      position={position}\n      ref={boxMesh}\n      onClick={() => setExpand(!expand)}\n      scale={props.scale}\n      castShadow>\n      <boxBufferGeometry attach='geometry' args={args} />\n      <MeshWobbleMaterial\n        color={color}\n        speed={speed}\n        attach='material'\n        factor={0.6}\n      />\n    </a.mesh>\n  );\n};\n\nfunction App() {\n  const mouse = useRef([0, 0])\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <Canvas\n          style={{ flex: 1 }}\n          colorManagement\n          shadowMap\n          camera={{ position: [-5, 2, 10], fov: 60 }}>\n          <Suspense fallback={null}>\n            {/* This light makes things look pretty */}\n            <ambientLight intensity={0.3} />\n            {/* Our main source of light, also casting our shadow */}\n            <directionalLight\n              castShadow\n              position={[0, 10, 0]}\n              intensity={1.5}\n              shadow-mapSize-width={1024}\n              shadow-mapSize-height={1024}\n              shadow-camera-far={50}\n              shadow-camera-left={-10}\n              shadow-camera-right={10}\n              shadow-camera-top={10}\n              shadow-camera-bottom={-10}\n            />\n            {/* A light to help illumnate the spinning boxes */}\n            <pointLight position={[-10, 0, -20]} intensity={0.5} />\n            <pointLight position={[0, -10, 0]} intensity={1.5} />\n            <group>\n              {/* This mesh is the plane (The floor) */}\n              <mesh\n                rotation={[-Math.PI / 2, 0, 0]}\n                position={[0, -3, 0]}\n                receiveShadow>\n                <planeBufferGeometry attach='geometry' args={[100, 100]} />\n                <shadowMaterial attach='material' opacity={0.3} />\n              </mesh>\n\n              {/* <SpinningMesh\n                position={[0, 1, 0]}\n                color='lightgreen'\n                args={[5, 2, 1]}\n                speed={2}\n                rotate={false}\n              /> */}\n              {/* <SpinningMesh position={[-5, 1, -5]} color='pink' speed={6} />\n              <SpinningMesh position={[10, 1, -2]} color='pink' speed={6} /> */}\n              {/* <img src={logo} className=\"App-logo\" alt=\"logo\" /> */}\n            </group>\n            {/* Allows us to move the canvas around for different prespectives */}\n            {/* <OrbitControls /> */}\n            {/* <Box position={[0, 4, 0]} /> */}\n            {/* <Box position={[0, -2, 0]} /> */}\n            {/* <Text position={[0, -2, 0]} /> */}\n            <Particles count={2000} mouse={mouse} />\n          </Suspense>\n        </Canvas>\n\n        <p>\n          {`Site is under maintenance with React and Three.js ❤️`}\n        </p>\n      </header>\n    </div>\n  );\n}\n\n\n// function App() {\n//   return (\n//     <div className=\"App\">\n//       <Canvas>\n//         <ambientLight />\n//         <pointLight position={[10, 10, 10]} />\n//         <Box position={[-1.2, 0, 0]} />\n//         <Box position={[1.2, 0, 0]} />\n//       </Canvas>\n//     </div>\n//   )\n// }\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}